---
date: 2025-06-03
title: "How I Found a Stored XSS on Sony's PlayStation Community (And Got a T-Shirt)"
template: post
slug: sony-xss-stored-vulnerability
categories:
  - Technical
tags:
  - bug-bounty

---

What up, fellow hackers and bug bounty hunters! Today, I'm breaking down a sick find I stumbled upon while digging around in Sony's infrastructure. This is the technical deep dive into how some heavy recon, a little bit of luck, and a clever Cloudflare WAF bypass led to a Stored XSS vulnerability on a Sony community website, and a sweet t-shirt to add to my collection.

## The Recon Grind: Mapping Out Sony's Kingdom

When you're dealing with a massive corporation like Sony, you know their digital footprint is gonna be huge. My first move is always to get a bird's-eye view of their domains. I started by using a few of my go-to tools to gather as much intel as possible.

### Domain Gathering

First, I hit up `crt.sh` to pull down all the domains from their certificate transparency logs. A simple `curl` and `jq` command gets the job done:

```bash
curl -s "https://crt.sh/?q=%.sony.com&output=json" | jq -r '.[].name_value' | sed 's/\*\.//g' | sort -u > sony_domains.txt
```

This gave me a solid starting list. To expand on this, I used Google dorking with specific keywords I found from my initial recon, such as:

*   `"Sony Assurance Inc"`
*   `"Sony Bank Incorporated"`
*   `"Sony Finance International.Inc"`
*   `"Sony Corporation"`
*   `"Sony Pictures Entertainment"`

I also ran my `domain_gatherer.py` script to automate the generation of more dorks for manual searching on Google and Shodan to find even more related domains and subdomains.

### Shodan Queries

Shodan is a goldmine for finding internet-facing devices. I used the following queries to find Sony assets:

*   `ssl.cert.subject.cn:sony`
*   `org:"Sony Corporation of America"`

These queries helped me find servers and other assets that might not have been in the certificate transparency logs.

I also utilized tools like **whoxyrm** to find related domains based on WHOIS data and **SecurityTrails** to explore historical DNS data and find even more subdomains. This multi-source approach ensures the most comprehensive list of potential targets.

### Subdomain Enumeration

With a list of root domains, it was time to find subdomains. No single tool finds everything, so I used a combination of my favorite subdomain enumeration tools like `subfinder`, `amass`, and `assetfinder` to build the most comprehensive list possible. I ran each tool on my list of domains and then combined and deduplicated the results.

Here's an example of how I'd run one of them, like `subfinder`:

```bash
subfinder -dL sony_domains.txt -o sony_subdomains.txt
```

After running all my subdomain tools, I combined the results into a single file.

### Deduplication

To make sure I had a clean list, I used `sort -u` to remove any duplicate entries:

```bash
cat sony_subdomains_*.txt | sort -u > all_subdomains.txt
```

This left me with a massive list of over 30,000 unique potential targets.

### Finding Live Hosts

Next, I needed to see which of these were actually live. `httpx` is my tool of choice for this. I piped my list of subdomains to `httpx` to check for live hosts, specifically looking for `200` and `302` status codes:

```bash
cat sony_subdomains.txt | httpx -silent -status-code -mc 200,302 -o live_hosts.txt
```

This command filters out the noise and gives me a clean list of web servers that are up and running.

### Filtering Other Status Codes

I also saved the hosts with other status codes to a separate file. These are often interesting for directory fuzzing and other tests:

```bash
cat all_subdomains.txt | httpx -silent -status-code -fc 200,302 -o other_hosts.txt
```

## The Discovery: A Wild Comment Field Appears

Now for the fun part: manually exploring the live hosts. I was crawling through pages when I landed on `vulnerable.app`. It looked like a community forum for PlayStation gamers. I noticed a comment section on one of the posts, and my spidey-senses started tingling.


![Vulnerable App Web Page](https://i.imgur.com/nhVYInU.png)
![Vulnerable App Web Page](https://i.imgur.com/CV6aN1j.png)



I registered for an account, logged in, and went back to the comment section. I started with a classic, simple payload to see if the input was being sanitized:

```html
<b>hello</b>
```

I posted the comment, and the text was bold. This was a good sign that the application was rendering HTML. Time to escalate.

### Testing Other Features: The Voting System

Before diving deeper into the XSS, I also took a quick look at the comment voting feature. I tested for race conditions by sending multiple vote/unvote requests simultaneously using Burp Intruder to see if I could manipulate the vote count. The application handled it correctly, so I moved on.

## The Bypass: Outsmarting the Firewall

My next step was to try a basic XSS payload, but as soon as I did, I was hit with a Cloudflare firewall page. Bummer. But not a deal-breaker. When I'm looking for WAF bypasses, I've found that X (formerly Twitter) can be a great resource. A quick search led me to this beauty:

```html
onmouseover=alert&#x00000000028;1&#x00000000029; autofocus>
```

This payload is designed to trick the WAF by using a few clever techniques:

*   `&#x00000000028;` and `&#x00000000029;` are just encoded parentheses `(` and `)`. The extra zeros are there to confuse the WAF's regex patterns.
*   `onmouseover` is a common event handler that executes JavaScript when the mouse pointer is moved over an element.
*   `autofocus` is an HTML5 attribute that automatically focuses the element when the page loads, which, in combination with `onmouseover`, can trigger the payload.

I went back to the comment section and inspected the POST request in Burp Suite. The request to `/api/secure/post/test-8/comment` sent a JSON body with two interesting fields: `content` and `contentEmbed`. The `content` field seemed to be for the main text of the comment and likely had some sanitization, while `contentEmbed` was used for embedding media like YouTube videos. My theory was that the `contentEmbed` field might have weaker input validation, making it a prime target for injection.

I modified the JSON body to include my payload in the `contentEmbed` field:

```json
{"content":"<p><!-- contentEmbed --></p>","contentEmbed":"https://www.youtube.com/embed/testhhhhhhh\" onmouseover=alert&#x00000000028;1&#x00000000029; autofocus>"}
```

I sent the modified request, refreshed the page, and as soon as my mouse moved over the embedded video, the XSS popped. I had found a Stored XSS vulnerability.

![Vulnerable App Web Page](https://i.imgur.com/nqlZtDZ.png)


At this point, I took a screenshot of the XSS alert to include in my report as proof of concept.

## The Impact and Report

A Stored XSS on a high-traffic community site like this is a serious issue. An attacker could use this vulnerability to:

*   Steal session cookies and hijack user accounts.
*   Redirect users to malicious websites.
*   Display fake login forms to phish for credentials.
*   Execute any arbitrary JavaScript on behalf of the user.

I immediately stopped my testing and reported my findings to Sony through their HackerOne program. They were quick to respond, and within a few days, the vulnerability was patched. As a thank you, they sent me a Sony swag t-shirt.

## Conclusion

This was a fun bug to hunt, and it just goes to show that even the biggest companies can have vulnerabilities hiding in plain sight. It also highlights the importance of thorough reconnaissance and creative thinking when it comes to bypassing security measures. Keep hacking, and maybe you'll be the next one to get a sweet t-shirt from Sony.

## References

[1] [crt.sh](https://crt.sh/)  
[2] [subfinder - GitHub](https://github.com/projectdiscovery/subfinder)  
[3] [httpx - GitHub](https://github.com/projectdiscovery/httpx)
